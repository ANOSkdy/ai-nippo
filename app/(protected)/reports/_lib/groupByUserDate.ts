export type SessionLite = {
  start: string;
  end: string;
  machineId?: string | number | null;
  machineName?: string | null;
  workDescription?: string | null;
  autoGenerated?: boolean | null;
};

export type DailyGroup = {
  userId: string | number;
  userName: string;
  date: string;
  earliestStart: string;
  latestEnd: string;
  totalMin: number;
  workedH: number;
  overH: number;
  sessions: SessionLite[];
};

type InputSession = Record<string, unknown> & {
  date?: unknown;
  userId?: unknown;
  userRecordId?: unknown;
  userName?: unknown;
  durationMin?: unknown;
  hours?: unknown;
  start?: unknown;
  end?: unknown;
  clockInAt?: unknown;
  clockOutAt?: unknown;
  machineId?: unknown;
  machineName?: unknown;
  workDescription?: unknown;
  autoGenerated?: unknown;
};

function toTrimmedString(value: unknown): string | null {
  if (typeof value === 'string') {
    const trimmed = value.trim();
    return trimmed.length > 0 ? trimmed : null;
  }
  if (typeof value === 'number' && Number.isFinite(value)) {
    return String(value);
  }
  return null;
}

function toNumber(value: unknown): number | null {
  if (typeof value === 'number' && Number.isFinite(value)) {
    return value;
  }
  if (typeof value === 'string') {
    const trimmed = value.trim();
    if (!trimmed) return null;
    const parsed = Number.parseFloat(trimmed);
    return Number.isFinite(parsed) ? parsed : null;
  }
  return null;
}

function parseDateKey(value: unknown): string | null {
  const str = toTrimmedString(value);
  if (!str) return null;
  if (/^\d{4}-\d{2}-\d{2}$/.test(str)) {
    return str;
  }
  return null;
}

function parseTime(value: unknown): { text: string; ms: number | null } | null {
  const str = toTrimmedString(value);
  if (!str) return null;
  let ms = Number.NaN;
  const parsed = Date.parse(str);
  if (Number.isFinite(parsed)) {
    ms = parsed;
  } else {
    const normalized = str.replace(' ', 'T');
    const fallback = Date.parse(normalized);
    if (Number.isFinite(fallback)) {
      ms = fallback;
    } else {
      const replaced = str.replace(/\//g, '-').replace(' ', 'T');
      const fallback2 = Date.parse(replaced);
      if (Number.isFinite(fallback2)) {
        ms = fallback2;
      } else {
        ms = Number.NaN;
      }
    }
  }
  return { text: str, ms: Number.isFinite(ms) ? ms : null };
}

const BREAK_MINUTES = 1.5 * 60;
const STANDARD_WORK_MINUTES = 7.5 * 60;

export function groupByUserDate(input: InputSession[]): DailyGroup[] {
  const groups = new Map<string, DailyGroup>();

  for (const session of input) {
    const date = parseDateKey(session.date);
    if (!date) {
      continue;
    }

    const userName = toTrimmedString(session.userName);
    if (!userName) {
      continue;
    }

    const userIdRaw = session.userId ?? session.userRecordId ?? session.userName;
    const userIdStr = toTrimmedString(userIdRaw);
    const userId: string | number = userIdStr ?? userName;

    const startInfo = parseTime(session.start ?? session.clockInAt);
    const endInfo = parseTime(session.end ?? session.clockOutAt);

    const durationMin = toNumber(session.durationMin);
    const hoursValue = toNumber(session.hours);
    const minutes =
      durationMin != null
        ? Math.max(0, durationMin)
        : hoursValue != null
          ? Math.max(0, hoursValue * 60)
          : 0;

    const machineId = session.machineId as string | number | null | undefined;
    const machineName = toTrimmedString(session.machineName);
    const workDescription = toTrimmedString(session.workDescription);
    const autoGenerated = typeof session.autoGenerated === 'boolean' ? session.autoGenerated : null;

    const key = `${userName}@@${String(userId)}@@${date}`;
    const existing = groups.get(key);
    if (!existing) {
      groups.set(key, {
        userId,
        userName,
        date,
        earliestStart: startInfo?.text ?? '',
        latestEnd: endInfo?.text ?? '',
        totalMin: minutes,
        workedH: 0,
        overH: 0,
        sessions: [
          {
            start: startInfo?.text ?? '',
            end: endInfo?.text ?? '',
            machineId: machineId ?? null,
            machineName: machineName ?? null,
            workDescription: workDescription ?? null,
            autoGenerated,
          },
        ],
      });
      const group = groups.get(key);
      if (group) {
        const startMs = startInfo?.ms;
        if (startMs != null) {
          (group as unknown as { _earliest?: number })._earliest = startMs;
        }
        const endMs = endInfo?.ms;
        if (endMs != null) {
          (group as unknown as { _latest?: number })._latest = endMs;
        }
      }
      continue;
    }

    existing.totalMin += minutes;
    existing.sessions.push({
      start: startInfo?.text ?? '',
      end: endInfo?.text ?? '',
      machineId: machineId ?? null,
      machineName: machineName ?? null,
      workDescription: workDescription ?? null,
      autoGenerated,
    });

    const currentEarliest = (existing as unknown as { _earliest?: number })._earliest;
    const startMs = startInfo?.ms;
    if (startMs != null && (currentEarliest == null || startMs < currentEarliest)) {
      existing.earliestStart = startInfo?.text ?? existing.earliestStart;
      (existing as unknown as { _earliest?: number })._earliest = startMs;
    } else if (!existing.earliestStart && startInfo?.text) {
      existing.earliestStart = startInfo.text;
    }

    const currentLatest = (existing as unknown as { _latest?: number })._latest;
    const endMs = endInfo?.ms;
    if (endMs != null && (currentLatest == null || endMs > currentLatest)) {
      existing.latestEnd = endInfo?.text ?? existing.latestEnd;
      (existing as unknown as { _latest?: number })._latest = endMs;
    } else if (!existing.latestEnd && endInfo?.text) {
      existing.latestEnd = endInfo.text;
    }
  }

  const result: DailyGroup[] = [];
  for (const group of groups.values()) {
    const workedMinutes = Math.max(0, group.totalMin - BREAK_MINUTES);
    const workedHours = workedMinutes / 60;
    const overHours = Math.max(0, workedHours - STANDARD_WORK_MINUTES / 60);
    group.workedH = workedHours;
    group.overH = overHours;
    result.push(group);
  }

  result.sort((a, b) => {
    if (a.userName !== b.userName) {
      return a.userName.localeCompare(b.userName, 'ja');
    }
    if (a.date !== b.date) {
      return a.date.localeCompare(b.date);
    }
    return 0;
  });

  return result;
}
