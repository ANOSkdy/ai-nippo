# /reports 親子表示 → フラット表示 調査レポート

## 1. 対象ファイル一覧（入口）
- `app/reports/page.tsx`（/reports の本体ページ。親子UIとサマリ表示）
- `app/reports/print/page.tsx`（/reports/print の印刷ページ。親子UIの簡易表）
- `app/reports/_utils/reportData.ts`（フィルタ解析・集計コンテキスト生成・サマリ計算）
- `lib/report-groupers.ts`（日付キーでのグルーピング・稼働/超過計算・並び順）
- `lib/services/reports.ts`（セッション取得→ReportRow 生成、日次集計）
- `src/lib/sessions-reports.ts`（Airtable Sessions 取得・フィルタ・ソート・ID保持）

## 2. 親子UIの実装方式（削除対象UI）
### 親子 UI（/reports）
- UI方式: `details/summary` を使ったアコーディオン形式 + 子は `table` 行。
- 親行（集約ヘッダ）: `groups.map` 内の `<details>` と `<summary>`。
- 親専用 UI:
  - まとめ表示: `dateLabel / startJst / endJst / 稼働 / 超過 / 合計 / 件数`。
  - 展開/折りたたみ: `<summary className="cursor-pointer">` のクリックで子表を開閉。
  - 親行クリック領域: `<summary>` の grid レイアウトが実質トリガー。

**該当コード（抜粋）**
```tsx
{groups.map((group) => (
  <details key={group.key} className="rounded border bg-white">
    <summary className="grid cursor-pointer ...">
      <span>{group.dateLabel}</span>
      ...
      <span>{group.count}件</span>
    </summary>
    <div className="space-y-3 border-t px-4 py-3">
      <table>...{group.items.map(...)}...</table>
    </div>
  </details>
))}
```

### 親子 UI（/reports/print）
- UI方式: 1つの `<table>` の中で「親行（summary）」→「子行（items）」を直列表示。
- 親専用 UI:
  - 親行は `bg-gray-100` の summary 行で日付/稼働/超過などを文字列結合表示。

**該当コード（抜粋）**
```tsx
{groups.map((group) => (
  <Fragment key={`${group.dateLabel}-block`}>
    <tr key={`${group.dateLabel}-summary`} className="bg-gray-100">
      <td colSpan={6}>
        {group.dateLabel} / IN {group.startJst ?? '—'} / OUT {group.endJst ?? '—'} ...
      </td>
    </tr>
    {group.items.map((row, index) => (
      <tr key={`${row.year}-${row.month}-${row.day}-${row.siteName}-${index}`}>...</tr>
    ))}
  </Fragment>
))}
```

## 3. データ形状（親子構造）と生成箇所
### 型定義
- 親: `ReportRowGroup`
- 子: `ReportRowWithStats[]`（`ReportRow` + `workingMinutes/overtimeMinutes/rawDurationMinutes`）

**該当コード（抜粋）**
```ts
export type ReportRowGroup = {
  key: string; // YYYY-MM-DD
  year: number; month: number; day: number;
  dateLabel: string;
  totalWorkingMinutes: number;
  totalOvertimeMinutes: number;
  count: number;
  startJst?: string | null;
  endJst?: string | null;
  items: ReportRowWithStats[];
};
```

### 生成ロジック
- `buildReportContext` → `groupReportRowsByDate(filteredRows)` で親子構造を生成。
- `groupReportRowsByDate` が `key=YYYY-MM-DD` で group を作成し、`items` に `ReportRow` を push。
- `groupReportRowsByDate` で以下を計算:
  - `group.totalWorkingMinutes` / `group.totalOvertimeMinutes`
  - `group.startJst` / `group.endJst`
  - `group.items` は `ReportRowWithStats` に変換（`workingMinutes/overtimeMinutes` 付与）

**該当コード（抜粋）**
```ts
const groups = groupReportRowsByDate(filteredRows);
```
```ts
const entry = map.get(key) ?? { key, ..., items: [] };
(entry.items as ReportRow[]).push(row);
...
const computedItems: ReportRowWithStats[] = decorated.map((item) => ({
  ...(item.row as ReportRow),
  workingMinutes: displayWorking,
  overtimeMinutes: roundedOvertime,
  rawDurationMinutes: item.rawDurationMinutes,
}));
...
group.items = computedItems;
```

### 親キー
- `ReportRowGroup.key` = `YYYY-MM-DD`。
- `toKey(row)` で `year/month/day` をゼロ埋めして生成。

### 子配列
- `ReportRowGroup.items` が子配列。
- 子要素は `ReportRowWithStats`。

### 子の保持フィールド（主なもの）
- `ReportRow` 由来: `year/month/day/siteName/clientName/startJst/endJst/autoGenerated/startTimestampMs/endTimestampMs/durationMinutes` など。
- `ReportRowWithStats` 追加: `workingMinutes/overtimeMinutes/rawDurationMinutes`。

## 4. サマリ計算（合計/超過/件数）の依存
### 表示箇所
- /reports 上部の「合計時間/超過/件数」は `buildReportContext` 結果を使用。
- /reports/print のヘッダでも同様に表示。

**該当コード（抜粋）**
```tsx
const {
  groups,
  autoCount,
  overallMinutes,
  totalRecords,
  totalDisplayedHours,
  totalOvertimeHours,
} = await buildReportContext(filters);
```

### 計算関数
- `buildReportContext` 内で集計。
- 重要: 合計は「親配列 (groups) を reduce」している。

**該当コード（抜粋）**
```ts
const groups = groupReportRowsByDate(filteredRows);
const totalWorkingMinutes = groups.reduce((sum, group) => sum + group.totalWorkingMinutes, 0);
const totalOvertimeMinutes = groups.reduce((sum, group) => sum + group.totalOvertimeMinutes, 0);
const overallMinutes = totalWorkingMinutes + totalOvertimeMinutes;
const totalRecords = filteredRows.length;
```

### 入力データ
- 合計/超過: `groups`（親配列）由来。
- 件数: `filteredRows`（子のフラット配列）長。
- `autoCount`: `filteredRows` の `autoGenerated` 件数。

### 変更禁止ポイント（計算依存）
- `groupReportRowsByDate` 内で稼働/超過の計算・丸め・休憩控除を行っているため、
  「表示のフラット化」でも計算関数は温存すべき。
- 特に `getTimeCalcConfig()` の設定値が計算に影響するため、
  データ生成段階を変えると結果差異が出る可能性がある。

## 5. 1レコードの安定キー候補
### 現状の key
- /reports: `key={`${row.year}-${row.month}-${row.day}-${row.siteName}-${index}`}`
- /reports/print: 同様に `year-month-day-siteName-index`
- **index 混在で安定性が弱い**。

### 候補
- `SessionReportRow.id`（Airtable record id）が存在するが `ReportRow` に引き渡していない。
- `startTimestampMs + endTimestampMs + siteName` の組み合わせが比較的安定（ただし重複可能性あり）。
- `ReportRow` に `sessionId`/`recordId` を追加できれば最も堅牢。

**関連コード（抜粋）**
```ts
export type SessionReportRow = { id: string; ... }
```
```tsx
<tr key={`${row.year}-${row.month}-${row.day}-${row.siteName}-${index}`}>...</tr>
```

## 6. ソート順・フィルタ条件
### フィルタ条件（入力元）
- `parseFilters(searchParams)` が URL クエリ由来（`GET` フォーム）で取得。
- フィルタは `buildReportContext` で `rowsRaw` から `filteredRows` を作成。

**該当コード（抜粋）**
```ts
export function parseFilters(searchParams?: SearchParams): Filters {
  return {
    user: toSingleValue(params.user).trim(),
    site: toSingleValue(params.site).trim(),
    year: toNumberValue(params.year),
    month: toNumberValue(params.month),
    day: toNumberValue(params.day),
    auto: toAutoFilter(toSingleValue(params.auto).trim()),
  };
}
```
```ts
const filteredRows = rowsRaw.filter((row) => {
  if (filters.auto === 'only' && !row.autoGenerated) return false;
  if (filters.auto === 'exclude' && row.autoGenerated) return false;
  if (filters.year && row.year !== filters.year) return false;
  if (filters.month && row.month !== filters.month) return false;
  if (filters.day && row.day !== filters.day) return false;
  if (filters.site && row.siteName !== filters.site) return false;
  return true;
});
```

### 並び順（ソートキー）
- `fetchSessionReportRows` が `date asc` → `startMs asc` → `userName` → `id` でソート。
- `groupReportRowsByDate` では group を `key desc`（日付降順）にソート。
- group 内 `items` は `startJst asc` → `endJst asc` でソート。

**該当コード（抜粋）**
```ts
function sortSessions(rows: SessionReportRow[]): SessionReportRow[] {
  return rows.sort((a, b) => {
    const dateA = a.date ?? '';
    const dateB = b.date ?? '';
    if (dateA !== dateB) return dateA.localeCompare(dateB);
    const startA = a.startMs ?? Infinity;
    const startB = b.startMs ?? Infinity;
    if (startA !== startB) return startA - startB;
    const nameA = a.userName ?? '';
    const nameB = b.userName ?? '';
    const nameCompare = nameA.localeCompare(nameB, 'ja');
    if (nameCompare !== 0) return nameCompare;
    return a.id.localeCompare(b.id);
  });
}
```
```ts
groups.sort((a, b) => (a.key < b.key ? 1 : -1));
```
```ts
function sortGroupItems(items: ReportRow[]): ReportRow[] {
  return [...items].sort((a, b) => {
    const aStart = a.startJst ?? '';
    const bStart = b.startJst ?? '';
    if (aStart && bStart && aStart !== bStart) return aStart.localeCompare(bStart, 'ja');
    const aEnd = a.endJst ?? '';
    const bEnd = b.endJst ?? '';
    if (aEnd && bEnd && aEnd !== bEnd) return aEnd.localeCompare(bEnd, 'ja');
    return 0;
  });
}
```

### フィルタ変更がデータ生成に与える影響
- `parseFilters` → `buildReportContext` で `filteredRows` 作成後に `groupReportRowsByDate` が実行されるため、
  **フィルタは親子生成の前段で適用**される。

## 7. フラット化実装の影響範囲（推奨方針）
- 推奨方針: **計算は維持し、表示のみ children を flatten**。
  - サマリ計算は `groupReportRowsByDate` を前提としているため、
    ここを bypass すると合計/超過の算出方法が変わる。
  - UI 側だけをフラット化するなら、`groups.flatMap(group => group.items)` を使った
    表示変更が安全。

- 影響が出る可能性のある箇所
  - **React key**: 現状 `index` が混入しているためフラット化時のキー再設計が必要。
  - **ソート**: 親子 UI では `groups` の日付降順が効いているため、
    フラット表示でも日付キーでの降順を再現する必要がある。
  - **空表示**: `groups.length === 0` の分岐はフラット化後も `filteredRows.length` 等に差し替えが必要。
  - **印刷ページ**: 親行の summary 行が消えると日次合計の可視性が落ちる。

## 未解決課題（残確認）
- `ReportRow` に `SessionReportRow.id` を伝搬するかどうか（key 安定性）。
- `groupReportRowsByDate` が計算している「日次の稼働/超過」定義が、
  フラット表示でも UI で明示的に必要かどうか。
- `filters.site` の候補抽出が `rowsRaw` 由来のため、
  フラット表示で「絞り込みを先に適用した候補一覧」にするかどうか。
