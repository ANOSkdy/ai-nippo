import { usersTable } from '@/lib/airtable';
import { formatMinutes } from '@/lib/format';
import { groupReportRowsByDate, type ReportRowGroup } from '@/lib/report-groupers';
import type { ReportRow } from '@/lib/reports/pair';
import { getReportRowsByUserName } from '@/lib/services/reports';

export type SearchParams = Record<string, string | string[] | undefined>;

export type AutoFilter = 'all' | 'only' | 'exclude';

export type Filters = {
  user: string;
  site: string;
  year?: number;
  month?: number;
  day?: number;
  auto?: AutoFilter;
};

export type ReportContext = {
  filters: Filters;
  rowsRaw: ReportRow[];
  filteredRows: ReportRow[];
  groups: ReportRowGroup[];
  autoCount: number;
  totalWorkingMinutes: number;
  totalOvertimeMinutes: number;
  overallMinutes: number;
  totalRecords: number;
  totalBaseHours: number;
  totalOvertimeHours: number;
  totalDisplayedHours: number;
  availableYears: number[];
  availableMonths: number[];
  availableDays: number[];
  availableSites: string[];
};

function toSingleValue(value: string | string[] | undefined): string {
  if (Array.isArray(value)) {
    return value[0] ?? '';
  }
  return value ?? '';
}

function toNumberValue(value: string | string[] | undefined): number | undefined {
  const single = toSingleValue(value).trim();
  if (!single) return undefined;
  const parsed = Number.parseInt(single, 10);
  return Number.isFinite(parsed) ? parsed : undefined;
}

function toAutoFilter(value: string): AutoFilter | undefined {
  if (value === 'only' || value === 'exclude') {
    return value;
  }
  return undefined;
}

export function parseFilters(searchParams?: SearchParams): Filters {
  const params = searchParams ?? {};
  return {
    user: toSingleValue(params.user).trim(),
    site: toSingleValue(params.site).trim(),
    year: toNumberValue(params.year),
    month: toNumberValue(params.month),
    day: toNumberValue(params.day),
    auto: toAutoFilter(toSingleValue(params.auto).trim()),
  };
}

export async function fetchUsers(): Promise<string[]> {
  const records = await usersTable
    .select({ fields: ['name'], sort: [{ field: 'name', direction: 'asc' }] })
    .all();
  const names = new Set<string>();
  for (const record of records) {
    const name = typeof record.fields.name === 'string' ? record.fields.name : null;
    if (name) {
      names.add(name);
    }
  }
  return Array.from(names).sort((a, b) => a.localeCompare(b, 'ja'));
}

export function formatQuarterHours(minutes: number): string {
  const safe = Number.isFinite(minutes) ? Math.max(0, Math.round(minutes)) : 0;
  const quarters = Math.round(safe / 15);
  const hours = quarters / 4;
  if (quarters % 4 === 0) {
    return `${hours.toFixed(1)}`;
  }
  const text = hours.toFixed(2).replace(/0$/, '');
  return text;
}

export function formatWorkingHours(minutes: number): string {
  return formatQuarterHours(minutes);
}

export function formatTotalWorkHours(hours: number): string {
  const safe = Number.isFinite(hours) ? hours : 0;
  const rounded = Math.round(safe * 10) / 10;
  return `${rounded.toFixed(1)}`;
}

export function groupTotalMinutes(group: ReportRowGroup): number {
  return group.totalWorkingMinutes + group.totalOvertimeMinutes;
}

export function formatHoursFromMinutes(minutes: number): string {
  return formatQuarterHours(minutes);
}

export async function buildReportContext(filters: Filters): Promise<ReportContext> {
  const rowsRaw: ReportRow[] = filters.user ? await getReportRowsByUserName(filters.user) : [];

  const filteredRows = rowsRaw.filter((row) => {
    if (filters.auto === 'only' && !row.autoGenerated) return false;
    if (filters.auto === 'exclude' && row.autoGenerated) return false;
    if (filters.year && row.year !== filters.year) return false;
    if (filters.month && row.month !== filters.month) return false;
    if (filters.day && row.day !== filters.day) return false;
    if (filters.site && row.siteName !== filters.site) return false;
    return true;
  });

  const autoCount = filteredRows.filter((row) => row.autoGenerated).length;

  const groups = groupReportRowsByDate(filteredRows);
  const totalWorkingMinutes = groups.reduce((sum, group) => sum + group.totalWorkingMinutes, 0);
  const totalOvertimeMinutes = groups.reduce((sum, group) => sum + group.totalOvertimeMinutes, 0);
  const overallMinutes = totalWorkingMinutes + totalOvertimeMinutes;
  const totalRecords = filteredRows.length;
  const totalBaseHours = totalWorkingMinutes / 60;
  const totalOvertimeHours = totalOvertimeMinutes / 60;
  const totalDisplayedHours = totalBaseHours + totalOvertimeHours;

  const availableYears = Array.from(new Set(rowsRaw.map((row) => row.year))).sort((a, b) => a - b);
  const availableMonths = Array.from(new Set(rowsRaw.map((row) => row.month))).sort((a, b) => a - b);
  const availableDays = Array.from(new Set(rowsRaw.map((row) => row.day))).sort((a, b) => a - b);
  const availableSites = Array.from(
    new Set(rowsRaw.map((row) => row.siteName).filter((name): name is string => Boolean(name && name.trim()))),
  ).sort((a, b) => a.localeCompare(b, 'ja'));

  return {
    filters,
    rowsRaw,
    filteredRows,
    groups,
    autoCount,
    totalWorkingMinutes,
    totalOvertimeMinutes,
    overallMinutes,
    totalRecords,
    totalBaseHours,
    totalOvertimeHours,
    totalDisplayedHours,
    availableYears,
    availableMonths,
    availableDays,
    availableSites,
  };
}

export function formatMinutesSummary(minutes: number): string {
  return formatMinutes(minutes);
}
